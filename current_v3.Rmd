---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library("hadron")
source("morefunctions.R")
```

Make a filelist
```{r filelist}
filelist <- getorderedfilelist(path="/home/gross/Documents/heavymesons/out_th0/", 
        basename="b", ending="/mes_contr_H_C_S_H")
filelist2 <- getorderedfilelist(path="/home/gross/Documents/heavymesons/out_th0/", 
        basename="a", ending="/mes_contr_H_C_S_H")
filelist <- c(filelist, filelist2)

filelist <- substr(filelist, 1, nchar(filelist[1])-17)

tsink <- 64
tins <- 48

```

Only 199 files, b712 (?) did not run properly, but maybe not worth the time to redo it because the signal is bad anyway
Read in data for vector currents


define function for arbitrary mu, nu
In Antonios note, he only mentions AA and VV, so take out mixed parts
AA and VV are weighted with renormalizations factors
reformulate Antonios note:

$Y^2(t)=\frac{M_{D_s}}{\exp(M_{D_s}\cdot dt)}\frac{\hat{w}_0^2}{C_2(t)}\left(Z_V^2C_4^{V_0V_0}(t) + Z_A^2C_4^{A_0A_0}(t)\right)$
```{r}
##four point function is not symmetric, do not symmetrise, also take care of divison
getcmunu <- function(filellist, Time=128, mu=0, nu=0, boot.R=100, print=FALSE, boot.l=10, ZA, ZV, dZA, dZV, theta = 0){
aa <- readnissatextcf(filelist, smear_combs_to_read=c(paste("mes_contr_H_C_Dth", theta, "_A_C_P_H_H_S_H", sep="")), Time=Time, 
        corrtype="general", symmetrise=FALSE, sym.vec=c(1), 
        combs_to_read=data.frame(op1_idx="C_H", op2_idx=paste("Dth", theta, "_A", mu, "_C_P_H_H_S_H", sep=""), spin_comb=paste("A", nu, "P5", sep="")))
aa <- bootstrap.cf(aa, boot.R=boot.R, boot.l=boot.l)

vv <- readnissatextcf(filelist, smear_combs_to_read=c(paste("mes_contr_H_C_Dth", theta, "_V_C_P_H_H_S_H", sep="")), Time=Time, 
        corrtype="general", symmetrise=FALSE, sym.vec=c(1), 
        combs_to_read=data.frame(op1_idx="C_H", op2_idx=paste("Dth", theta, "_V", mu, "_C_P_H_H_S_H", sep=""), spin_comb=paste("V", nu, "P5", sep="")))
vv <- bootstrap.cf(vv, boot.R=boot.R, boot.l=boot.l)

bootstrapZA <- parametric.bootstrap(boot.R, c(ZA), c(dZA))
bootstrapZV <- parametric.bootstrap(boot.R, c(ZV), c(dZV))
# print(dim(bootstrapZA))
# print(dim(aa$cf.tsboot$t))

aa <- multiplycfbootstrap(cf=aa, central=ZA^2, bootstraps=bootstrapZA^2)
vv <- multiplycfbootstrap(cf=vv, central=ZV^2, bootstraps=bootstrapZV^2)


plusterms <- add.cf(aa, vv)
if(print){
print("vv")
print(vv$cf.tsboot$t0)
print("vv-error")
print(vv$cf.tsboot$se)
print("aa")
print(aa$cf.tsboot$t0)
}
return (plusterms)
}
```


How to get $w_0$?
```{r}
#plot(czerozero, log="y")
ZA <- 0.74294
dZA <- 0.00024
ZV <- 0.706379
dZV <- 0.000024
ZA <- 1
ZV <- 1
dZA <- 0
dZV <- 0
czerozero <- getcmunu(filellist = filelist, mu=0, nu=0, boot.R=100, ZA=ZA, ZV=ZV, dZA=dZA, dZV=dZV)
czeroone <- getcmunu(filellist = filelist, mu=0, nu=1, boot.R=100, ZA=ZA, ZV=ZV, dZA=dZA, dZV=dZV)
print(czerozero)
plot(czerozero, xlab="t/a", ylab="C_00(t)", main="C_00", xlim=c(0, 48), log="y")


```

symmetrisation makes 65 timeslices out of 128: measure from 0..127, 0 stays the same, 1+127, 2+126, ..., 64 stays the same -> now frm 0..64, 65 times. Do not symmetrise four-point function, symmetrisation does not make sense with more than one inserted time. But do symmetrise two-point-function to get better signal for mass, matrix element, unsymmetrise later to get values for all timeslices. Calculate smeared-smeared and local-smeared contribution to determine masses, influence of smearing.

```{r}
scalarlocal <- readnissatextcf(filelist, smear_combs_to_read=c("/mes_contr_H_C_S_H"), Time=128,
                corrtype="general", combs_to_read=data.frame(op1_idx="C_H", op2_idx="S_H", spin_comb="P5P5"),
                symmetrise=TRUE, sym.vec=c(1))
scalarlocal <- bootstrap.cf(scalarlocal, boot.R=100, boot.l=10)
scalarsmeared <- readnissatextcf(filelist, smear_combs_to_read=c("/mes_contr_H_C_H_H_S_H"), Time=128,
                corrtype="general", combs_to_read=data.frame(op1_idx="C_H", op2_idx="H_H_S_H", spin_comb="P5P5"),
                symmetrise=TRUE, sym.vec=c(1))
scalarsmeared <- bootstrap.cf(scalarsmeared, boot.R=100, boot.l=10)
scalarsmearedalltimeslices <- unsymmetrise.cf(scalarsmeared)

print(scalarsmeared$cf[1, ])
plot(scalarlocal, log="y", xlab="t/a", ylab="C(t)", main="smeared-smeared two point function")
plot(scalarsmeared, log="y", xlab="t/a", ylab="C(t)", main="smeared-local two point function")
```

get two-point-functions, both smeared-local and smeared-smeared. Determine correlators, use effective mass to get a sense of boundaries for following matrixfit

```{r}
scalarlocaleffmass <- bootstrap.effectivemass(scalarlocal)
scalarsmearedeffmass <- bootstrap.effectivemass(scalarsmeared)
scalarlocaleffmass <- fit.effectivemass(scalarlocaleffmass, t1=10, t2=20)
scalarsmearedeffmass <- fit.effectivemass(scalarsmearedeffmass, t1=14, t2=36)
plot(scalarlocaleffmass, ylim=c(0.79, 0.82), xlab="t/a", ylab="m_eff(t)", main="smeared-local two point function")
plot(scalarsmearedeffmass, ylim=c(0.79, 0.82), xlab="t/a", ylab="m_eff(t)", main="smeared-smeared two point function")
plot(scalarsmearedeffmass, xlab="t/a", ylab="m_eff(t)", main="smeared-smeared two point function")
# print(scalarsmearedeffmass$effMass)
# summary(scalarsmearedeffmass)
```

Do matrixfits to get to $m_c$, $Z$. Fits work only for useCov=FALSE, otherwise 
Error in chol.default(M) : 
  the leading minor of order 20 is not positive definite
```{r}
localmatrix <- matrixfit(scalarlocal, t1=10, t2=20, sym.vec=c("cosh"), useCov=FALSE)
smearmatrix <- matrixfit(scalarsmeared, t1=15, t2=37, sym.vec=c("cosh"), useCov=FALSE)
summary(localmatrix)
summary(smearmatrix)
# plot(smearmatrix)
```

is dt t_sink - t_j > 0  or t_j-t_sink < 0?
here, $\hat{w}_0=1$.
```{r}
mds <- c(smearmatrix$t0[1], smearmatrix$t[,1])
dt <- 48-64
expmdsdt <- exp(mds*dt)
mdsoverexpmdsdt <- mds / expmdsdt
# print(mdsoverexpmdsdt)
ytwo <- multiplycfbootstrap(czerozero, mdsoverexpmdsdt[1], mdsoverexpmdsdt[2:length(mds)])
ytwo <- ytwo / unsymmetrise.cf(scalarsmeared)
df <- data.frame(t=seq(0,47), val=ytwo$cf0[49:2], err=ytwo$tsboot.se[49:2])
plot(ytwo, xlim=c(0, 20), log="y")
plotwitherror(x=df$t, y=df$val, dy=df$err, log="y", xlab="t2-t1", ylab="Y^2")
# write.table(df, "Ytwoth0tins48.csv", row.names=F, col.names=T)
```

